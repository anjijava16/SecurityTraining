Session hijacking via MITM attack
=====

Level: Simple.

What is this attack?
-----

A session hijack is where you have a session - an ongoing HTTP conversation - with a website, and an attacker gains access to this session, communicating with the site as if he were you. This might possibly kick you off, or more likely you will be unaware that he is also using your session. The session may or may not be authenticated, but it is likely that it is if any sensitive information is involved. This means that the attacker can do what ever you can on the site in question at the time of the hijack - change your password, read your mail, transfer money, whatever. For demonstration purposes though, the object of the attack in this module is to post messages from another user's account without his permission. Something offensive that'll get that user into trouble, perhaps.

A man in the middle (MITM) attack is where the attacker can intercept the network communications between your browser and the server, and read, block or modify it. There are many places this can be done, from malware on your PC to unsecured or compromised wireless networks to unscrupulous ISPs and governments. These events are outside the control of the web app developer or the user. This is the attack vector for the session hijack in this module. There are many others which we will look at in other modules.


Examples of real-world MITM attacks
-----


Exercise 1: Find out how your app works, using Fiddler
-----

First, a general discussion of what a session is. HTTP is stateless, meaning that each GET/POST/whatever and its response between a client and a server is independent of the next. Clearly this isn't how it looks to the user, what we conceptualize is a session - an ongoing conversation between you and the site. So some extra plumbing is required, and at a high level of abstraction, this involves there being some additional data being passed back and forth saying 'this HTTP request is part of a specific conversation'. There are many architectures for doing this, and the samples in this course form a small subset of those. The session architecture also encompasses concerns about authentication and how the data is persisted between requests on the client and/or server sides, but for now we're going to ignore that and just worry about how that data is passed.

*Dev-specific*
The first part of the exercise is to look at the architecture/design docs (if there are any - there aren't for these sample apps) and the code, to see how it is supposed to work. Maybe you wrote the code, so you think you know how it works, and you know it basically works, right?

The next part of the exercise is to observe the web traffic the app generates, with Fiddler. Start Fiddler and drive the sample app through a cycle of logging on and submitting a post. Look at all the requests and figure out exactly what information is being passed to maintain the session, and how - what part of the request/response is it? 

In the MEAN_stack sample, its a JWT, passed as the body of the response of the post to /api/sessions, and in the X-Auth request header of (some) subsequent requests. A JWT is a JSON web token, which is an encoded signed bit of data, with a payload generated by the app - in this case, just the username. Copy the string out of Fiddler and take a look, using http://jwt.io/. Not that it's not encrypted, and it doesn't have anything identifying IP addresses or anything like that. It's just a bearer token - if you're the bearer of the token you've got the session. The signature simply tells the server that it created this token and it hasn't been tampered with. 

We know that the MEAN_stack sample is an AngularJS app, and a glance at the (unminified) app.js using Chrome dev tools confirms that. This JS source code IS PUBLIC - any user can see it, and the attacker can see that the app gets the token, uses it to get a user from the users API and passes it to the server when submitting a new post. So now have all the information we need to hijack a session in this sample.


Exercise 2: Run the hijack by hand, using Fiddler
-----

In fact, you've already done the first part of the attack. Fiddler is an HTTP proxy, which is to say a (benign) man in the middle. It's reading the HTTP traffic between client and server. If it was not benign, it might be sending any session IDs it found to (e.g.) an API on the attacker's own site, where they might be decoded and logged. Either way, watch the victims traffic and extract the session ID (JWT).

The exploit is now trivially simple. Using Fiddler, capture a valid response to a post to /api/session. Save it as a file and paste in the session ID, adjusting the content length to the right number as necessary. Now use the AutoResponder tab in Fiddler to have it send back this response rather than going to the server for an /api/sessions post. Put your attacker hat on, fire up a different browser and login, with no user name or password. You are now logged in as the victim. Post offensive messages at will, and turn the AutoResponder off when you're finished.


Exercise 3: Use Fiddler to find unprotected session IDs
-----

We can do some basic filtering using Fiddler's Filters tab - for instance we can set a filter to flag (highlight) requests which send the X-Auth header.

More complex behaviour can be scripted using FiddlerScript - see http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse. As an exercise, make Fiddler throw up an alert box whenever the word "password" appears in HTTP traffic. This is a useful test in itself - we've been concentrating on hijacking the session ID, but stealing users' passwords by MITM is an even worse attack.


*dev-specific*
Exercise 4: Mitigate by using HTTPS throughout. TBD
-----

HTTPS throughout - HSTS
Secure cookies


Other mitigations. TBD
-----

Expiry policies
Reauthentication
Separating session from auth, changing sessionID after auth


Notes on specific tech. TBD
-----


Further reading. TBD
-----

https://www.owasp.org/index.php/Session_Management
