Session hijacking via MITM attack
=====

Level: Simple.

What is this attack?
-----

A session hijack is where you have a session - an ongoing HTTP conversation - with a website, and an attacker gains access to this session, communicating with the site as if he were you. You may or may not be aware that the attacker is using your session. The session may or may not be authenticated, but it is likely that it is if any sensitive information is involved. This means that the attacker can do what ever you can on the site in question at the time of the hijack - change your password, read your mail, transfer money, whatever. For demonstration purposes though, the object of the attack in this module is to post messages from another user's account without his permission. Something offensive that'll get that user into trouble, perhaps.

A man in the middle (MITM) attack is where the attacker can intercept the network communications between your browser and the server, and read, block or modify it. There are many places this can be done, from malware on your PC to unsecured or compromised wireless networks to unscrupulous ISPs and governments. These events are outside the control of the web app developer or the user. This is the attack vector for the session hijack in this module. There are many others which we will look at in other modules.


Examples of real-world MITM attacks
-----


Exercise 1: Find out how your app works, using Fiddler
-----

First, a general discussion of what a session is. HTTP is stateless, meaning that each GET/POST/whatever and its response between a client and a server is independent of the next. Clearly this isn't how it looks to the user, what we conceptualize is a session - an ongoing conversation between you and the site. So some extra plumbing is required, and at a high level of abstraction, this involves there being some additional data being passed back and forth saying 'this HTTP request is part of a specific conversation'. There are many architectures for doing this, and the samples in this course form a small subset of those. The session architecture also encompasses concerns about authentication and how the data is persisted between requests on the client and/or server sides, but for now we're going to ignore that and just worry about how that data is passed.

*Dev-specific*
The first part of the exercise is to look at the architecture/design docs (if there are any - there aren't for these sample apps) and the code, to see how it is supposed to work. Maybe you wrote the code, so you think you know how it works, and you know it basically works, right?

The next part of the exercise is to observe the web traffic the app generates, with Fiddler. Start Fiddler and drive the sample app through a cycle of logging on and submitting a post. Look at all the requests and figure out exactly what information is being passed to maintain the session, and how - what part of the request/response is it? 

In the MEAN_stack sample, its a JWT, passed as the body of the response of the post to /api/sessions, and in the X-Auth request header of (some) subsequent requests. A JWT is a JSON web token, which is an encoded signed bit of data, with a payload generated by the app - in this case, just the username. Copy the string out of Fiddler and take a look, using http://jwt.io/. Note that it's not encrypted, and it doesn't have anything identifying IP addresses or anything like that. It's just a bearer token - if you're the bearer of the token you've got the session. The signature simply tells the server that it created this token and it hasn't been tampered with. 

We know that the MEAN_stack sample is an AngularJS app, and a glance at the (unminified) app.js using Chrome dev tools confirms that. This JS source code IS PUBLIC - any user can see it, and the attacker can see that the app gets the token, uses it to get a user from the users API and passes it to the server when submitting a new post. So now have all the information we need to hijack a session in this sample.

In the Jade-Express-MySQL sample the information is passed as a cookie, set by the server on any request. The connect.sid is a signed ID for the session, but does not contain any data such as the username - that is all stored on the server, looked up using the session ID as a key. Again note that it's not encrypted, and it doesn't have anything identifying IP addresses or anything like that, though the cookie has attributes, which we will discuss later. Again it's just a cookie - if you've got the cookie you've got the session. The signature simply tells the server that it created this cookie and it hasn't been tampered with. FYI the format is `s%3A<ID>.<signature>`. Note that both Chrome and Firefox have extensions for editing cookies, which you should install. I've used EditThisCookie (Chrome) and Advanced Cookie Manager (Firefox)


Exercise 2: Run the hijack by hand, using Fiddler
-----

In fact, you've already done the first part of the attack. Fiddler is an HTTP proxy, which is to say a (benign) man in the middle. It's reading the HTTP traffic between client and server. If it was not benign, it might be sending any session IDs it found to (e.g.) an API on the attacker's own site, where they might be decoded and logged. Either way, watch the victim's traffic and extract the session ID (JWT or cookie). In the Jade-Express-MySQL sample use a logged in session for the victim.

The exploits are now trivially simple:

In the MEAN_stack sample, using Fiddler capture a valid response to a post to /api/session. Save it as a file and paste in the session ID, adjusting the content length to the right number as necessary. Now use the AutoResponder tab in Fiddler to have it send back this response rather than going to the server for an /api/sessions post. Put your attacker hat on, fire up a different browser and login, with no user name or password. You are now logged in as the victim. Post offensive messages at will, and turn the AutoResponder off when you're finished.

In the Jade-Express-MySQL sample, using the cookie editor extension in a different browser, replace the existing cookie with the one you extracted. You are now logged in as the victim. In fact you actually using the same session on the server in this sample - unlike the MEAN_stack sample, where session state is stored in the browser. This means that if the attacker logs out, the victim is logged out too.

*Dev-specific*
You may now be idly considering how to automate this process. But then you'd be writing malware, so don't :-). This course is about how to defend your applications, and we'll introduce some test/attack tools shortly.


Exercise 3: Use Fiddler to find unprotected session IDs
-----

We can do some basic filtering using Fiddler's Filters tab - for instance we can set a filter to flag (highlight) HTTP requests which send the X-Auth header.

More complex behaviour can be scripted using FiddlerScript - see http://docs.telerik.com/fiddler/KnowledgeBase/FiddlerScript/ModifyRequestOrResponse. For instance, you could make Fiddler throw up an alert box whenever the word "password" appears in HTTP traffic. This is a useful test in itself - we've been concentrating on hijacking the session ID, but stealing users' passwords by MITM is an even worse attack.

Now put this together to customise Fiddler so it complains if any session ID tokens/cookies are sent over HTTP for either of the samples - you should now have a detailed understanding of exactly what you want to catch on each sample app. This will be the basis of our testing for this module - you will just run the apps with Fiddler capturing HTTP requests and flagging the bad ones.

*Test-specific* There are some rules I cooked up earlier in the resources folder - these are specific to these sample apps, they'll need modifying for your real-world apps. @Devs, write your own ;-)


*dev-specific*
Exercise 5: Mitigate by using HTTPS throughout. TBD
-----

HTTPS throughout - HSTS
Secure cookies


Other mitigations. TBD
-----

Expiry policies
Reauthentication
Separating session from auth, changing sessionID after auth


Notes on specific tech. TBD
-----


Further reading. TBD
-----

https://www.owasp.org/index.php/Session_Management
